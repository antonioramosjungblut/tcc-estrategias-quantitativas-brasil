# C√≥digo MF14 ((EV/EBIT + P/VPA)/2) + ROIC + Momentum (1998‚Äì2024)
# Base: data_set_base_2.xlsx
# Sa√≠da: MF14_empresas.xlsx

library(readxl)
library(dplyr)
library(openxlsx)

# Arquivo base e sa√≠da
arquivo_entrada <- "data_set_base_2.xlsx"
arquivo_saida <- "MF14_empresas.xlsx"

# Ler todas as abas (anos)
abas <- excel_sheets(arquivo_entrada)

# Criar workbook de sa√≠da
wb <- createWorkbook()

for (aba in abas) {
  
  cat("Processando aba:", aba, "\n")
  
  # 1. Ler dados da aba
  dados <- read_excel(arquivo_entrada, sheet = aba)
  
  # 2. Renomear colunas
  dados <- dados %>%
    rename(
      Ticker = `Ticker`,
      EV_EBIT = `EV/EBIT atual`,
      PVPA = `P/VPA atual`,
      ROIC = `ROIC √∫ltimo balan√ßo em %`,
      MOM = `Retorno √∫ltimos 6 meses em %`
    )
  
  # 3. Converter para texto, limpar e converter para num√©rico
  dados <- dados %>%
    mutate(
      EV_EBIT = as.numeric(gsub(",", ".", gsub("[^0-9.-]", "", as.character(EV_EBIT)))),
      PVPA    = as.numeric(gsub(",", ".", gsub("[^0-9.-]", "", as.character(PVPA)))),
      ROIC    = as.numeric(gsub(",", ".", gsub("[^0-9.-]", "", as.character(ROIC)))),
      MOM     = as.character(MOM),
      MOM     = trimws(MOM),
      MOM     = ifelse(MOM %in% c("", "-", "--", "N/A", "n/a", "NA", "na"), NA, MOM),
      MOM     = as.numeric(gsub(",", ".", gsub("[^0-9.-]", "", MOM)))
    )
  
  # 4. Filtrar empresas v√°lidas:
  #    - EV/EBIT > 0
  #    - P/VPA > 0
  #    - ROIC > 0
  #    - Momentum pode ser negativo, mas n√£o pode ser vazio
  dados_filtrados <- dados %>%
    filter(!is.na(EV_EBIT), EV_EBIT > 0,
           !is.na(PVPA), PVPA > 0,
           !is.na(ROIC), ROIC > 0,
           !is.na(MOM))
  
  # 5. Criar rankings individuais
  dados_classificados <- dados_filtrados %>%
    mutate(
      Rank_EVEBIT = rank(EV_EBIT, ties.method = "first"),  # menor = melhor
      Rank_PVPA   = rank(PVPA,   ties.method = "first"),   # menor = melhor
      Rank_ROIC   = rank(-ROIC,  ties.method = "first"),   # maior = melhor
      Rank_MOM    = rank(-MOM,   ties.method = "first")    # maior = melhor
    ) %>%
    # 6. Calcular Rank Final
    mutate(
      Rank_Final = ((Rank_EVEBIT + Rank_PVPA) / 2) + Rank_ROIC + Rank_MOM
    ) %>%
    arrange(Rank_Final) %>%
    mutate(Posicao_Final = row_number()) %>%
    # 7. Manter apenas os 30 primeiros
    filter(Posicao_Final <= 30)
  
  # 8. Selecionar colunas finais
  resultado <- dados_classificados %>%
    select(Posicao_Final, Ticker, EV_EBIT, PVPA, ROIC, MOM,
           Rank_EVEBIT, Rank_PVPA, Rank_ROIC, Rank_MOM, Rank_Final)
  
  # 9. Adicionar aba no Excel de sa√≠da
  addWorksheet(wb, aba)
  writeData(wb, aba, resultado)
}

# 10. Salvar o arquivo consolidado
saveWorkbook(wb, arquivo_saida, overwrite = TRUE)

cat("\nArquivo 'MF14_empresas.xlsx' criado com sucesso!\n")





















# ================================
# C√≥digo gerar planilhas de pre√ßos MF12 (1998‚Äì2024)
# ================================

# Instalar pacotes se n√£o tiver
# install.packages("readxl")
# install.packages("openxlsx")

library(readxl)
library(openxlsx)

# Caminhos dos arquivos
empresas_file <- "MF14_empresas.xlsx"
precos_file   <- "precos_diarios_acoes.xlsx"

# Lista de anos
anos <- 1998:2024

# Intervalos A:B para cada ano
intervalos <- list(
  "1998" = "A71:B1113",
  "1999" = "A336:B1375",
  "2000" = "A592:B1635",
  "2001" = "A853:B1895",
  "2002" = "A1114:B2156",
  "2003" = "A1376:B2418",
  "2004" = "A1636:B2679",
  "2005" = "A1896:B2940",
  "2006" = "A2157:B3200",
  "2007" = "A2419:B3461",
  "2008" = "A2680:B3722",
  "2009" = "A2941:B3983",
  "2010" = "A3201:B4244",
  "2011" = "A3462:B4505",
  "2012" = "A3723:B4765",
  "2013" = "A3984:B5026",
  "2014" = "A4245:B5287",
  "2015" = "A4506:B5549",
  "2016" = "A4766:B5810",
  "2017" = "A5027:B6070",
  "2018" = "A5288:B6330",
  "2019" = "A5550:B6592",
  "2020" = "A5811:B6853",
  "2021" = "A6071:B7114",
  "2022" = "A6331:B7375",
  "2023" = "A6593:B7635",
  "2024" = "A6854:B7896"
)

# Estilos (opcional ‚Äî mant√©m formato de data e n√∫mero)
dateStyle <- createStyle(numFmt = "dd/mm/yyyy")
numStyle  <- createStyle(numFmt = "GENERAL")

# Loop pelos anos
for (ano in anos) {
  cat("Processando ano:", ano, "\n")
  
  # --- Ler tickers da aba correspondente ---
  tickers <- read_excel(empresas_file,
                        sheet = as.character(ano),
                        range = "B2:B31",
                        col_names = FALSE)[[1]]
  
  tickers <- tickers[!is.na(tickers) & tickers != ""]
  
  # --- Criar workbook para o ano ---
  wb <- createWorkbook()
  
  # --- Para cada ticker, copiar dados da planilha de pre√ßos ---
  for (ticker in tickers) {
    dados <- tryCatch({
      df <- read_excel(precos_file,
                       sheet = ticker,
                       range = intervalos[[as.character(ano)]],
                       col_names = FALSE,
                       col_types = c("date", "numeric"))
      colnames(df) <- c("Data", "Valor")
      df
    }, error = function(e) NULL)
    
    if (!is.null(dados)) {
      addWorksheet(wb, ticker)
      writeData(wb, ticker, dados, withFilter = FALSE)
      
      # Aplicar estilos (datas e n√∫meros)
      addStyle(wb, ticker, dateStyle, rows = 2:(nrow(dados) + 1), cols = 1, gridExpand = TRUE)
      addStyle(wb, ticker, numStyle,  rows = 2:(nrow(dados) + 1), cols = 2, gridExpand = TRUE)
    } else {
      cat("Aba n√£o encontrada:", ticker, "no ano", ano, "\n")
    }
  }
  
  # --- Salvar arquivo do ano ---
  saveWorkbook(wb, paste0("precos_empresas_MF14_", ano, ".xlsx"), overwrite = TRUE)
}
















# ==========================
# C√ÅLCULO DOS PESOS DE MARKOWITZ (M√âDIA-VARI√ÇNCIA) EM LOOP 1998‚Äì2024
# ==========================

if (!require("pacman")) install.packages("pacman")
pacman::p_load(readxl, dplyr, openxlsx, PerformanceAnalytics, PortfolioAnalytics,
               ROI, ROI.plugin.glpk, ROI.plugin.quadprog, xts, zoo)


# ==========================
# Fun√ß√£o para processar cada ano
# ==========================
calcular_pesos_media_variancia <- function(ano) {
  
  arquivo <- paste0("precos_empresas_MF14_", ano, ".xlsx")
  cat("\nProcessando:", arquivo, "\n")
  
  if (!file.exists(arquivo)) {
    cat("Arquivo n√£o encontrado, pulando...\n")
    return(NULL)
  }
  
  abas <- excel_sheets(arquivo)
  
  # 1. Leitura e jun√ß√£o das s√©ries
  ler_precos <- function(sheet) {
    dados <- read_excel(arquivo, sheet = sheet)
    colnames(dados)[1:2] <- c("Data", "Preco")
    dados <- dados %>%
      mutate(Data = as.Date(Data)) %>%
      arrange(Data)
    colnames(dados)[2] <- sheet
    return(dados)
  }
  
  lista_precos <- lapply(abas, ler_precos)
  dados_precos <- Reduce(function(x, y) full_join(x, y, by = "Data"), lista_precos)
  dados_precos <- dados_precos %>% arrange(Data)
  
  # Preenche buracos (√∫ltimo valor v√°lido e reverso)
  dados_precos <- dados_precos %>%
    mutate(across(-Data, zoo::na.locf, na.rm = FALSE)) %>%
    mutate(across(-Data, zoo::na.locf, fromLast = TRUE))
  
  # 2. C√°lculo dos retornos logar√≠tmicos
  retornos <- diff(log(as.matrix(dados_precos[,-1])))
  colnames(retornos) <- colnames(dados_precos)[-1]
  retornos <- na.omit(retornos)
  
  # 3. Converter para xts com datas
  datas <- dados_precos$Data[-1]  # remove a primeira data (pois diff reduz 1 linha)
  retornos_xts <- xts(retornos, order.by = as.Date(datas))
  
  # 4. Defini√ß√£o do portf√≥lio
  port <- portfolio.spec(assets = colnames(retornos_xts))
  port <- add.constraint(portfolio = port, type = "full_investment")  # soma = 1
  port <- add.constraint(portfolio = port, type = "long_only")        # pesos ‚â• 0
  
  # 5. Objetivos de otimiza√ß√£o (m√©dia e vari√¢ncia)
  port <- add.objective(portfolio = port, type = "return", name = "mean")
  port <- add.objective(portfolio = port, type = "risk", name = "var", multiplier = 0.5)
  
  # 6. Otimiza√ß√£o via ROI
  resultado_opt <- optimize.portfolio(R = retornos_xts, portfolio = port, optimize_method = "ROI")
  
  # 7. Extra√ß√£o dos pesos
  pesos <- extractWeights(resultado_opt)
  
  # 8. Salvar resultados
  df_pesos <- data.frame(
    Ticker = names(pesos),
    Peso = round(as.numeric(pesos), 6)
  )
  
  nome_saida <- paste0("pesos_MF14_", ano, ".xlsx")
  write.xlsx(df_pesos, nome_saida)
  
  cat("‚úÖ", nome_saida, "criado com sucesso!\n")
  invisible(df_pesos)
}

# ==========================
# Loop principal 1998‚Äì2024
# ==========================
anos <- 1998:2024

for (ano in anos) {
  calcular_pesos_media_variancia(ano)
}

cat("\n==============================\n")
cat("‚úÖ TODOS OS ARQUIVOS PROCESSADOS (1998‚Äì2024)\n")
cat("==============================\n")












#‚úÖ Estrat√©gia de corre√ß√£o

#Impor um peso m√≠nimo positivo para todos os ativos
#‚Üí Por exemplo, w_i ‚â• 0.01 / n, garantindo que ningu√©m tenha peso zero absoluto.
#Isso for√ßa o modelo a distribuir minimamente o capital, sem permitir exclus√µes totais.

#Regularizar a matriz de covari√¢ncia (opcional, mas ajuda muito)
#‚Üí Adicionar um pequeno termo √† diagonal (Œ£ + ŒªI), com Œª = 1e-6, para garantir que a matriz seja bem-condicionada (positiva definida), evitando solu√ß√µes nulas.



# ==========================
# C√ÅLCULO DOS PESOS DE MARKOWITZ (M√âDIA-VARI√ÇNCIA, PESO M√çNIMO > 0)
# ==========================

if (!require("pacman")) install.packages("pacman")
pacman::p_load(readxl, dplyr, openxlsx, PerformanceAnalytics, PortfolioAnalytics,
               ROI, ROI.plugin.glpk, ROI.plugin.quadprog, xts, zoo)

# ==========================
# Fun√ß√£o principal
# ==========================
calcular_pesos_media_variancia <- function(ano) {
  
  arquivo <- paste0("precos_empresas_MF14_", ano, ".xlsx")
  cat("\nProcessando:", arquivo, "\n")
  
  if (!file.exists(arquivo)) {
    cat("Arquivo n√£o encontrado, pulando...\n")
    return(NULL)
  }
  
  abas <- excel_sheets(arquivo)
  
  # 1. Leitura e uni√£o das s√©ries
  ler_precos <- function(sheet) {
    dados <- read_excel(arquivo, sheet = sheet)
    colnames(dados)[1:2] <- c("Data", "Preco")
    dados <- dados %>%
      mutate(Data = as.Date(Data)) %>%
      arrange(Data)
    colnames(dados)[2] <- sheet
    return(dados)
  }
  
  lista_precos <- lapply(abas, ler_precos)
  dados_precos <- Reduce(function(x, y) full_join(x, y, by = "Data"), lista_precos)
  dados_precos <- dados_precos %>% arrange(Data)
  
  # Preenche valores faltantes
  dados_precos <- dados_precos %>%
    mutate(across(-Data, zoo::na.locf, na.rm = FALSE)) %>%
    mutate(across(-Data, zoo::na.locf, fromLast = TRUE))
  
  # 2. C√°lculo dos retornos logar√≠tmicos
  retornos <- diff(log(as.matrix(dados_precos[,-1])))
  colnames(retornos) <- colnames(dados_precos)[-1]
  retornos <- na.omit(retornos)
  datas <- dados_precos$Data[-1]
  retornos_xts <- xts(retornos, order.by = as.Date(datas))
  
  # 3. Regulariza√ß√£o da covari√¢ncia
  Sigma <- cov(retornos_xts)
  n <- ncol(Sigma)
  lambda <- 1e-6
  Sigma <- Sigma + diag(lambda, n)  # regulariza
  
  # 4. Defini√ß√£o do portf√≥lio com peso m√≠nimo
  port <- portfolio.spec(assets = colnames(retornos_xts))
  port <- add.constraint(portfolio = port, type = "full_investment")   # soma = 1
  
  # Define um peso m√≠nimo positivo (ex: 1% distribu√≠do igualmente)
  peso_minimo <- 0.01 / n  # ‚âà 0.0003 se tiver 30 ativos
  port <- add.constraint(portfolio = port, type = "box",
                         min = rep(peso_minimo, n),
                         max = rep(1, n))
  
  # 5. Objetivos: m√©dia e vari√¢ncia
  port <- add.objective(portfolio = port, type = "return", name = "mean")
  port <- add.objective(portfolio = port, type = "risk", name = "var", multiplier = 0.5)
  
  # 6. Otimiza√ß√£o
  resultado_opt <- optimize.portfolio(R = retornos_xts, portfolio = port, optimize_method = "ROI")
  pesos <- extractWeights(resultado_opt)
  
  # Normaliza (garantia extra)
  pesos <- pesos / sum(pesos)
  
  # 7. Exporta resultados
  df_pesos <- data.frame(
    Ticker = names(pesos),
    Peso = round(as.numeric(pesos), 6)
  )
  
  nome_saida <- paste0("pesos_MF14_", ano, ".xlsx")
  write.xlsx(df_pesos, nome_saida)
  
  cat("‚úÖ", nome_saida, "criado com sucesso! Soma dos pesos:", round(sum(df_pesos$Peso), 6), "\n")
  invisible(df_pesos)
}

# ==========================
# LOOP 1998‚Äì2024
# ==========================
anos <- 1998:2024
for (ano in anos) {
  calcular_pesos_media_variancia(ano)
}

cat("\n==============================\n")
cat("‚úÖ TODOS OS ARQUIVOS PROCESSADOS (1998‚Äì2024)\n")
cat("==============================\n")



#estrat√©gia de correcao com filtro de datas
# ==========================================
# MARKOWITZ M√âDIA-VARI√ÇNCIA ROBUSTO (w>0 e soma=1)
# Per√≠odo de 3 anos (01/04/(ano-3) a 31/03/(ano))
# ==========================================
if (!require("pacman")) install.packages("pacman")
pacman::p_load(readxl, openxlsx, dplyr, PerformanceAnalytics, xts, zoo, lubridate)

# -----------------------------
# Fun√ß√£o principal
# -----------------------------
calcular_pesos_MF13 <- function(ano) {
  arquivo <- paste0("precos_empresas_MF13_", ano, ".xlsx")
  cat("\nProcessando:", arquivo, "\n")
  if (!file.exists(arquivo)) {
    cat("Arquivo n√£o encontrado, pulando...\n")
    return(NULL)
  }
  
  # Define intervalo de datas
  data_inicio <- as.Date(paste0(ano - 3, "-04-01"))
  data_fim    <- as.Date(paste0(ano, "-03-31"))
  cat("Per√≠odo considerado:", format(data_inicio), "at√©", format(data_fim), "\n")
  
  abas <- excel_sheets(arquivo)
  
  # --- Leitura e uni√£o das s√©ries ---
  ler_precos <- function(sheet) {
    dados <- read_excel(arquivo, sheet = sheet)
    colnames(dados)[1:2] <- c("Data", "Preco")
    dados <- dados %>%
      mutate(Data = as.Date(Data)) %>%
      filter(Data >= data_inicio & Data <= data_fim) %>%
      arrange(Data)
    colnames(dados)[2] <- sheet
    return(dados)
  }
  
  lista_precos <- lapply(abas, ler_precos)
  dados_precos <- Reduce(function(x, y) full_join(x, y, by = "Data"), lista_precos)
  dados_precos <- dados_precos %>% arrange(Data)
  
  # Preencher valores faltantes
  dados_precos <- dados_precos %>%
    mutate(across(-Data, zoo::na.locf, na.rm = FALSE)) %>%
    mutate(across(-Data, zoo::na.locf, fromLast = TRUE))
  
  # --- Retornos logar√≠tmicos ---
  retornos <- diff(log(as.matrix(dados_precos[,-1])))
  colnames(retornos) <- colnames(dados_precos)[-1]
  retornos <- na.omit(retornos)
  datas <- dados_precos$Data[-1]
  retornos_xts <- xts(retornos, order.by = as.Date(datas))
  
  # --- Par√¢metros ---
  mu <- colMeans(retornos_xts)
  Sigma <- cov(retornos_xts)
  n <- length(mu)
  
  # Regulariza√ß√£o para evitar singularidade
  Sigma <- Sigma + diag(1e-6, n)
  
  # -----------------------------
  # Otimiza√ß√£o via optim()
  # -----------------------------
  objetivo <- function(w) {
    w <- w / sum(w)
    risco <- as.numeric(t(w) %*% Sigma %*% w)
    retorno <- as.numeric(sum(w * mu))
    return(risco - 0.5 * retorno)
  }
  
  penalizacao <- function(w) {
    p1 <- sum(pmax(-w, 0)^2)
    p2 <- (sum(w) - 1)^2
    return(1e5 * (p1 + p2))
  }
  
  objetivo_penalizado <- function(w) objetivo(w) + penalizacao(w)
  
  w_inicial <- rep(1/n, n)
  
  resultado <- optim(
    par = w_inicial,
    fn = objetivo_penalizado,
    method = "L-BFGS-B",
    lower = rep(1e-6, n),
    upper = rep(1, n),
    control = list(maxit = 5000)
  )
  
  w_otimo <- resultado$par / sum(resultado$par)
  
  # -----------------------------
  # Exporta resultados
  # -----------------------------
  df_pesos <- data.frame(
    Ticker = names(mu),
    Peso = round(w_otimo, 6)
  )
  
  nome_saida <- paste0("pesos_MF13_", ano, ".xlsx")
  write.xlsx(df_pesos, nome_saida)
  cat("‚úÖ", nome_saida, "criado com sucesso! Soma dos pesos:", round(sum(w_otimo), 6), "\n")
  invisible(df_pesos)
}

# -----------------------------
# Loop 1998‚Äì2024
# -----------------------------
anos <- 1998:2024
for (ano in anos) {
  calcular_pesos_MF13(ano)
}

cat("\n==============================\n")
cat("‚úÖ TODOS OS ANOS PROCESSADOS (1998‚Äì2024)\n")
cat("==============================\n")

üß† O que este c√≥digo faz diferente
Etapa				Diferen√ßa					Efeito
Otimiza√ß√£o			Usa optim() (gradiente num√©rico) em vez de ROI	Evita degenera√ß√£o do resolvedor
Peso m√≠nimo expl√≠cito (1e-6)	Nenhum ativo fica com peso 0			Todos os ativos participam
Penaliza√ß√£o suave		Mant√©m soma ‚âà 1 e evita pesos negativos		Est√°vel mesmo com ru√≠do
Regulariza√ß√£o da covari√¢ncia	Œ£ + 1e-6I						Garante matriz positiva definida
Normaliza√ß√£o final		w / sum(w)					Soma = 1 exatamente






















# =======================
# Instala√ß√£o / Carregamento de Pacotes
# =======================
if (!require("pacman")) install.packages("pacman")
pacman::p_load(readxl, openxlsx, dplyr, xts, zoo, PerformanceAnalytics)

# =======================
# Fun√ß√µes auxiliares
# =======================

# L√™ pre√ßos (Data, Preco) de TODAS as abas de um arquivo de pre√ßos
# e recorta pela janela [data_ini, data_fim].
read_prices_file <- function(price_file, data_ini, data_fim) {
  if (!file.exists(price_file)) stop("Arquivo de pre√ßos n√£o encontrado: ", price_file)
  sheets <- readxl::excel_sheets(price_file)
  
  all_prices <- lapply(sheets, function(s) {
    # Tenta ler duas colunas: Data (A) e Pre√ßo (B). Sem cabe√ßalho.
    df <- readxl::read_excel(price_file, sheet = s, col_names = FALSE,
                             col_types = c("date", "numeric"))
    if (ncol(df) < 2) return(xts::xts(order.by = as.Date(character())))
    names(df) <- c("Data", "Preco")
    
    # Datas e num√©ricos
    df$Data  <- as.Date(df$Data)
    df$Preco <- suppressWarnings(as.numeric(df$Preco))
    
    # Recorte da janela e remo√ß√£o de linhas inv√°lidas
    df <- df %>%
      dplyr::filter(!is.na(Data),
                    Data >= data_ini, Data <= data_fim,
                    !is.na(Preco))
    
    if (nrow(df) == 0) return(xts::xts(order.by = as.Date(character())))
    xts::xts(df$Preco, order.by = df$Data)
  })
  names(all_prices) <- sheets
  list(prices = all_prices, tickers = sheets)
}

# L√™ pesos A2:A31 (tickers) e B2:B31 (pesos) de um arquivo de pesos
read_weights_file <- function(weight_file) {
  if (!file.exists(weight_file)) stop("Arquivo de pesos n√£o encontrado: ", weight_file)
  # L√™ primeira planilha por padr√£o; ajuste se necess√°rio
  raw <- readxl::read_excel(weight_file, sheet = 1, range = "A2:B31", col_names = FALSE)
  names(raw) <- c("Ticker", "Peso")
  raw$Ticker <- as.character(raw$Ticker)
  raw$Peso   <- suppressWarnings(as.numeric(gsub(",", ".", as.character(raw$Peso))))
  raw <- raw %>% dplyr::filter(!is.na(Ticker), !is.na(Peso))
  # Normaliza pesos (caso n√£o some exatamente 1)
  if (nrow(raw) > 0) {
    s <- sum(raw$Peso, na.rm = TRUE)
    if (is.finite(s) && s > 0) raw$Peso <- raw$Peso / s
  }
  raw
}

# Calcula m√©tricas da carteira a partir da s√©rie de retornos di√°rios
calc_metrics <- function(returns) {
  returns <- as.numeric(returns)
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# Constr√≥i a s√©rie de retornos da CARTEIRA (Buy & Hold com pesos iniciais)
# - Junta pre√ßos por UNI√ÉO de datas
# - Forward-fill (na.locf) para p√≥s-deslistagem (retornos = 0 ap√≥s √∫ltimo pre√ßo)
# - Remove linhas ainda com NA (antes do 1¬∫ pre√ßo de algum ativo)
# - Wealth por ativo = pre√ßo / pre√ßo_inicial_alinhado
# - Valor da carteira = soma( w_i * wealth_i )
# - Retornos da carteira = Return.calculate(portfolio_value)
build_portfolio_returns <- function(prices_list, weight_df, data_ini, data_fim) {
  if (nrow(weight_df) == 0) stop("Arquivo de pesos sem linhas v√°lidas.")
  tickers_w <- weight_df$Ticker
  weights   <- weight_df$Peso
  
  # Mant√©m apenas tickers presentes em ambos (pesos e pre√ßos)
  commons <- intersect(names(prices_list), tickers_w)
  if (length(commons) < 1) stop("Nenhum ticker do arquivo de pesos encontrado no arquivo de pre√ßos.")
  
  # Reordena de acordo com a ordem do data frame de pesos
  commons <- tickers_w[tickers_w %in% commons]
  prices_to_merge <- prices_list[commons]
  
  # Merge por UNI√ÉO de datas
  px <- do.call(merge, c(prices_to_merge, all = TRUE))
  
  # Forward-fill (pre√ßos param de mudar ap√≥s o √∫ltimo valor -> retornos 0)
  px <- zoo::na.locf(px, fromLast = FALSE, na.rm = FALSE)
  
  # Remove linhas que ainda tenham NA (datas antes do 1¬∫ pre√ßo de algum ativo)
  px <- na.omit(px)
  if (NROW(px) < 2) stop("S√©rie de pre√ßos insuficiente ap√≥s alinhamento.")
  
  colnames(px) <- commons
  
  # Alinha vetor de pesos √† ordem das colunas
  w <- weights[match(colnames(px), tickers_w)]
  w[is.na(w)] <- 0
  # Normaliza de novo (se sobrar zeros)
  s <- sum(w)
  if (!is.finite(s) || s <= 0) stop("Soma de pesos n√£o positiva depois do alinhamento.")
  w <- w / s
  
  # Wealth por ativo (base 1 no primeiro dia comum)
  first_row <- as.numeric(px[1, ])
  wealth_mat <- sweep(as.matrix(px), 2, first_row, "/")
  
  # Valor da carteira (buy & hold com pesos iniciais)
  portfolio_value <- xts::xts(wealth_mat %*% w, order.by = zoo::index(px))
  
  # Retornos da carteira (di√°rios)
  port_rets <- PerformanceAnalytics::Return.calculate(portfolio_value, method = "discrete")
  port_rets <- na.omit(port_rets)
  
  list(returns = port_rets, portfolio_value = portfolio_value)
}

# =======================
# LOOP principal: 1998 ... 2024
# =======================
anos <- 1998:2024

for (ano in anos) {
  cat("Processando ano:", ano, "\n")
  
  # Janela 01/04/ANO ‚Üí 31/03/(ANO+1)
  data_ini <- as.Date(sprintf("%d-04-01", ano))
  data_fim <- as.Date(sprintf("%d-03-31", ano + 1))
  
  price_file <- sprintf("precos_empresas_MF14_%d.xlsx", ano)
  weight_file <- sprintf("pesos_MF14_%d.xlsx", ano)
  
  # L√™ arquivos
  pf <- try(read_prices_file(price_file, data_ini, data_fim), silent = TRUE)
  if (inherits(pf, "try-error")) { warning(paste("Falha ao ler pre√ßos em", price_file)); next }
  wf <- try(read_weights_file(weight_file), silent = TRUE)
  if (inherits(wf, "try-error")) { warning(paste("Falha ao ler pesos em", weight_file)); next }
  
  # S√©rie de retornos da carteira (Buy & Hold com pesos iniciais)
  br <- try(build_portfolio_returns(pf$prices, wf, data_ini, data_fim), silent = TRUE)
  if (inherits(br, "try-error")) { warning(paste("Falha ao montar carteira em", ano)); next }
  
  rets_xts <- br$returns
  rets_vec <- as.numeric(rets_xts)
  dates    <- zoo::index(rets_xts)
  
  # M√©tricas
  met <- calc_metrics(rets_vec)
  
  # S√©ries para exporta√ß√£o
  wealth <- cumprod(1 + rets_vec)
  drawd  <- PerformanceAnalytics::Drawdowns(rets_vec)
  
  series_df <- data.frame(
    Data         = as.Date(dates),
    Retorno      = rets_vec,
    Wealth_Index = wealth,
    Drawdown     = as.numeric(drawd)
  )
  
  # =======================
  # Exportar Excel do ano
  # =======================
  out_name <- sprintf("indices_resultados_MF14_%d.xlsx", ano)
  wb <- openxlsx::createWorkbook()
  openxlsx::addWorksheet(wb, "Resumo")
  openxlsx::writeData(wb, "Resumo", met)
  
  openxlsx::addWorksheet(wb, "Series")
  openxlsx::writeData(wb, "Series", series_df)
  
  openxlsx::saveWorkbook(wb, out_name, overwrite = TRUE)
  cat("Arquivo salvo:", out_name, "\n")
}