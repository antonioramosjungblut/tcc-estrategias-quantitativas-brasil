#Código para cálculo e índices de resultados MF1 2024:

# Instalação e carregamento dos pacotes necessários
install.packages("readxl")
install.packages("dplyr")
install.packages("lubridate")

if (!require("pacman")) install.packages("pacman")
pacman::p_load(readxl, openxlsx, dplyr, xts, PerformanceAnalytics, zoo)


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2024
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")










#Código para cálculo e índices de resultados MF1 2023:


# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2023
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2022:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2022
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")













#Código para cálculo e índices de resultados MF1 2021:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2021
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")













#Código para cálculo e índices de resultados MF1 2020:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2020
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2019:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2019
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2018:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2018
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")













#Código para cálculo e índices de resultados MF1 2017:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2017
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2016:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2016
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2015:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2015
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2014:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2014
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2013:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2013
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2012:
# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2012
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2011:
# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2011
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2010:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2010
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")












#Código para cálculo e índices de resultados MF1 2009:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2009
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2008:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2008
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2007:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2007
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2006:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2006
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")










#Código para cálculo e índices de resultados MF1 2005:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2005
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")










#Código para cálculo e índices de resultados MF1 2004:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2004
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2003:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2003
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2002:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2002
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2001:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2001
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 2000:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 2000
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 1999:


# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 1999
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")










#Código para cálculo e índices de resultados MF1 1998:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 1998
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")











#Código para cálculo e índices de resultados MF1 1997:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 1997
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")









#Código para cálculo e índices de resultados MF1 1996:

# =======================
# Pacotes
# =======================
library(readxl)
library(dplyr)
library(lubridate)
library(xts)
library(PerformanceAnalytics)
library(openxlsx)
library(zoo)

# =======================
# Funções auxiliares
# =======================

# Métricas da série de retornos da CARTEIRA
calc_metrics <- function(returns) {
  wealth_index <- cumprod(1 + returns)
  drawdowns <- PerformanceAnalytics::Drawdowns(returns)
  data.frame(
    Retorno_Anualizado      = (prod(1 + returns))^(252/length(returns)) - 1,
    Volatilidade_Anualizada = sd(returns, na.rm = TRUE) * sqrt(252),
    Max_Drawdown            = min(drawdowns, na.rm = TRUE)
  )
}

# BUY & HOLD (pesos iguais no início, sem rebalancear) — com tratamento de NAs líderes
portfolio_returns <- function(prices) {
  prices <- as.xts(prices)

  # Retornos por ativo; remove NAs líderes (linha 1 típica)
  rets <- Return.calculate(prices, method = "discrete")
  rets <- na.omit(rets)

  # Pesos iguais no INÍCIO
  w <- rep(1 / ncol(rets), ncol(rets))

  # Wealth individual (agora sem NAs líderes)
  wealth <- cumprod(1 + rets)

  # Valor da carteira = combinação dos wealths com pesos iniciais
  portfolio_value <- as.xts(wealth %*% w, order.by = index(wealth))

  # Série de retornos da carteira; remove NA inicial
  portfolio_rets <- na.omit(Return.calculate(portfolio_value, method = "discrete"))
  portfolio_rets
}

# =======================
# Leitura do arquivo
# =======================

ano <- 1996
file <- paste0("precos_empresas_MF1_", ano, ".xlsx")
sheets <- excel_sheets(file)

# Janela 01/04/ANO → 31/03/(ANO+1)
data_ini <- as.Date(sprintf("%d-04-01", ano))
data_fim <- as.Date(sprintf("%d-03-31", ano + 1))

# Leitura por aba (Data, Preco) já no recorte de datas
all_prices <- lapply(sheets, function(s) {
  # Se suas abas não têm cabeçalho, deixe col_names = FALSE.
  # Se TÊM cabeçalho, troque para col_names = TRUE e ajuste os nomes abaixo.
  df <- read_excel(file, sheet = s, col_names = FALSE, col_types = c("date", "numeric"))
  if (ncol(df) < 2) return(xts(order.by = as.Date(character())))
  names(df) <- c("Data", "Preco")

  df$Data <- as.Date(df$Data)
  df <- df %>% filter(!is.na(Data), Data >= data_ini, Data <= data_fim, !is.na(Preco))

  if (nrow(df) == 0) return(xts(order.by = as.Date(character())))
  xts(df$Preco, order.by = df$Data)
})
names(all_prices) <- sheets

# =======================
# Definição das carteiras
# =======================

top_portfolios <- list(
  Top5   = sheets[1:5],
  Top10  = sheets[1:10],
  Top15  = sheets[1:15],
  Top20  = sheets[1:20],
  Top30  = sheets[1:30]
)

n <- length(sheets)
q_size <- floor(n/5)
quintil_portfolios <- list(
  Quintil1 = sheets[1:q_size],
  Quintil2 = sheets[(q_size+1):(2*q_size)],
  Quintil3 = sheets[(2*q_size+1):(3*q_size)],
  Quintil4 = sheets[(3*q_size+1):(4*q_size)],
  Quintil5 = sheets[(4*q_size+1):n]
)

portfolios <- c(top_portfolios, quintil_portfolios)

# =======================
# Calcular retornos e métricas
# =======================

results <- list()
summary_df <- data.frame()

for (pname in names(portfolios)) {
  tickers <- portfolios[[pname]]

  # Mantém só tickers com ALGUM dado na janela
  tickers <- tickers[sapply(all_prices[tickers], function(x) NROW(x) > 0)]
  if (length(tickers) < 2) {
    warning(sprintf("Carteira %s tem menos de 2 ativos com dados na janela. Pulando.", pname))
    next
  }

  # Junta preços (UNIÃO de datas)
  prices <- do.call(merge, all_prices[tickers])

  # 1) Preenche para FRENTE (deslistagem → preço travado)
  prices <- na.locf(prices, fromLast = FALSE, na.rm = FALSE)

  # 2) Remove linhas em que AINDA haja NA em QUALQUER ativo
  #    (são datas antes do 1º preço de algum ticker; não dá pra ter pesos iguais nesse dia)
  prices <- na.omit(prices)

  colnames(prices) <- tickers

  # Série de retornos da CARTEIRA (buy & hold)
  rets <- portfolio_returns(prices)

  # Métricas
  metrics <- calc_metrics(rets)
  metrics$Carteira <- pname
  summary_df <- rbind(summary_df, metrics)

  # Séries p/ exportação
  wealth_index <- cumprod(1 + rets)
  drawdowns <- PerformanceAnalytics::Drawdowns(rets)

  df_out <- data.frame(
    Data         = index(rets),
    Retorno      = as.numeric(rets),
    Wealth_Index = as.numeric(wealth_index),
    Drawdown     = as.numeric(drawdowns)
  )
  results[[pname]] <- df_out
}

# =======================
# Exportar para Excel
# =======================

wb <- createWorkbook()
addWorksheet(wb, "Resumo")
writeData(wb, "Resumo", summary_df)

for (pname in names(results)) {
  addWorksheet(wb, pname)
  writeData(wb, pname, results[[pname]])
}

out_name <- sprintf("indices_resultados_MF1_%d.xlsx", ano)
saveWorkbook(wb, out_name, overwrite = TRUE)
cat("Arquivo salvo como", out_name, "\n")